#!/usr/bin/env node

// Required parameters:
// @raycast.schemaVersion 1
// @raycast.title Auto Fill OTP from Messages
// @raycast.mode silent
// @raycast.packageName NaverAutoFill

// Optional parameters:
// @raycast.icon üîê
// @raycast.description Monitor Messages DB for new OTP and auto-fill to Naver forms

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Messages DB Í≤ΩÎ°ú
const MESSAGES_DB = path.join(os.homedir(), 'Library/Messages/chat.db');

async function getLatestOTP() {
  try {
    if (!fs.existsSync(MESSAGES_DB)) {
      throw new Error('Messages DB not found');
    }

    // ÏµúÍ∑º Î©îÏãúÏßÄ 150Í∞úÏóêÏÑú 6ÏûêÎ¶¨ OTP ÏΩîÎìú Ï∞æÍ∏∞
    const query = `SELECT text FROM message WHERE text IS NOT NULL ORDER BY date DESC LIMIT 150;`;
    const result = execSync(`sqlite3 "${MESSAGES_DB}" "${query}"`, { encoding: 'utf8' });
    
    // 6ÏûêÎ¶¨ Ïà´Ïûê Ìå®ÌÑ¥ Ï∞æÍ∏∞
    const regex = /\b[0-9]{6}\b/;
    const lines = result.split('\n');
    
    for (const line of lines) {
      const match = line.match(regex);
      if (match) {
        return match[0];
      }
    }
    
    // ÌïòÏù¥Ìîà/Í≥µÎ∞± Ìè¨Ìï® Ìå®ÌÑ¥ÎèÑ ÏãúÎèÑ
    const spaceHyphenRegex = /\b[0-9][0-9 -]{4,}[0-9]\b/;
    for (const line of lines) {
      const match = line.match(spaceHyphenRegex);
      if (match) {
        const normalized = match[0].replace(/[ -]/g, '');
        if (/^[0-9]{6}$/.test(normalized)) {
          return normalized;
        }
      }
    }
    
    return null;
  } catch (error) {
    console.error('Error getting OTP:', error.message);
    return null;
  }
}

async function injectOTPToPage(otpCode) {
  const injectionJs = `
    (function() {
      try {
        console.log("Auto-filling OTP:", "${otpCode}");
        
        // OTP ÏûÖÎ†• ÌïÑÎìú Ï∞æÍ∏∞ (Îã§ÏñëÌïú ÏÑ†ÌÉùÏûê ÏãúÎèÑ)
        const otpSelectors = [
          'input[type="text"][name*="auth"]',
          'input[type="text"][id*="auth"]',
          'input[type="text"][class*="auth"]',
          'input[type="text"][placeholder*="Ïù∏Ï¶ù"]',
          'input[type="text"][placeholder*="ÏΩîÎìú"]',
          'input[type="tel"][name*="auth"]',
          'input[type="tel"][id*="auth"]',
          'input[type="number"][name*="auth"]',
          'input[type="number"][id*="auth"]',
          'input[maxlength="6"]',
          'input[data-testid*="auth"]',
          'input[data-cy*="auth"]'
        ];
        
        let otpField = null;
        
        for (const selector of otpSelectors) {
          const fields = document.querySelectorAll(selector);
          for (const field of fields) {
            if (field.offsetParent !== null && !field.disabled && !field.readOnly) {
              otpField = field;
              break;
            }
          }
          if (otpField) break;
        }
        
        if (!otpField) {
          // Î™®Îì† ÌÖçÏä§Ìä∏ ÏûÖÎ†• ÌïÑÎìú Ï§ëÏóêÏÑú ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Í≤ÉÏù¥ÎÇò ÎπÑÏñ¥ÏûàÎäî Í≤É Ï∞æÍ∏∞
          const allInputs = document.querySelectorAll('input[type="text"], input[type="tel"], input[type="number"]');
          for (const input of allInputs) {
            if (input.offsetParent !== null && !input.disabled && !input.readOnly) {
              if (document.activeElement === input || input.value.trim() === '') {
                otpField = input;
                break;
              }
            }
          }
        }
        
        if (otpField) {
          // Í∏∞Ï°¥ Í∞í ÌÅ¥Î¶¨Ïñ¥
          otpField.value = '';
          
          // Ìè¨Ïª§Ïä§ ÏÑ§Ï†ï
          otpField.focus();
          
          // OTP ÏΩîÎìú ÏûÖÎ†• (Ìïú Í∏ÄÏûêÏî© Ï≤úÏ≤úÌûà)
          let index = 0;
          const typeChar = () => {
            if (index < "${otpCode}".length) {
              otpField.value += "${otpCode}"[index];
              
              // ÏûÖÎ†• Ïù¥Î≤§Ìä∏ Î∞úÏÉùÏãúÌÇ§Í∏∞
              otpField.dispatchEvent(new Event('input', { bubbles: true }));
              otpField.dispatchEvent(new Event('change', { bubbles: true }));
              
              index++;
              setTimeout(typeChar, 100); // 100ms Í∞ÑÍ≤©ÏúºÎ°ú ÏûÖÎ†•
            } else {
              // Î™®Îì† ÏûÖÎ†• ÏôÑÎ£å ÌõÑ Îã§Ïùå Î≤ÑÌäº Ï∞æÏïÑÏÑú ÌÅ¥Î¶≠
              setTimeout(() => {
                const nextButtonSelectors = [
                  'button[type="submit"]',
                  'input[type="submit"]',
                  'button:contains("Îã§Ïùå")',
                  'button:contains("ÌôïÏù∏")',
                  'button:contains("Ïù∏Ï¶ù")',
                  'button[class*="next"]',
                  'button[class*="submit"]',
                  'button[id*="next"]',
                  'button[id*="submit"]',
                  'a[role="button"]:contains("Îã§Ïùå")',
                  '.btn:contains("Îã§Ïùå")',
                  '.button:contains("Îã§Ïùå")'
                ];
                
                let nextButton = null;
                
                for (const selector of nextButtonSelectors) {
                  if (selector.includes(':contains')) {
                    // jQuery Ïä§ÌÉÄÏùº ÏÑ†ÌÉùÏûêÎ•º ÏùºÎ∞ò ÏÑ†ÌÉùÏûêÎ°ú Î≥ÄÌôò
                    const baseSelector = selector.split(':contains')[0];
                    const text = selector.match(/\\(["'](.+?)["']\\)/)?.[1];
                    const buttons = document.querySelectorAll(baseSelector);
                    
                    for (const btn of buttons) {
                      if (btn.textContent.includes(text) && 
                          btn.offsetParent !== null && 
                          !btn.disabled) {
                        nextButton = btn;
                        break;
                      }
                    }
                  } else {
                    const btn = document.querySelector(selector);
                    if (btn && btn.offsetParent !== null && !btn.disabled) {
                      nextButton = btn;
                      break;
                    }
                  }
                  if (nextButton) break;
                }
                
                if (nextButton) {
                  console.log("Clicking next button:", nextButton);
                  nextButton.click();
                } else {
                  // ÏóîÌÑ∞ÌÇ§ ÏãúÎèÑ
                  otpField.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
                  console.log("Next button not found, tried Enter key");
                }
              }, 500);
            }
          };
          
          typeChar();
          console.log("OTP auto-fill completed");
          return "success";
        } else {
          console.log("OTP input field not found");
          return "field_not_found";
        }
      } catch (e) {
        console.error("OTP injection error:", e);
        return "error";
      }
    })();
  `;

  // Create temp JS file for injection
  const tempJsFile = path.join(__dirname, '.temp_otp_inject.js');
  fs.writeFileSync(tempJsFile, injectionJs, 'utf8');

  // Create AppleScript to inject OTP
  const appleScriptLines = [
    'tell application "Google Chrome"',
    '  activate',
    '  set found to false',
    '  set windowCount to count of windows',
    '  repeat with i from 1 to windowCount',
    '    set currentWindow to window i',
    '    set tabCount to count of tabs of currentWindow',
    '    repeat with j from 1 to tabCount',
    '      set currentTab to tab j of currentWindow',
    '      if URL of currentTab contains "nid.naver.com" then',
    '        set active tab index of currentWindow to j',
    '        set index of currentWindow to 1',
    '        set jsContent to read POSIX file "' + tempJsFile.replace(/\\/g, '/') + '"',
    '        tell currentTab',
    '          execute javascript jsContent',
    '        end tell',
    '        set found to true',
    '        exit repeat',
    '      end if',
    '    end repeat',
    '    if found then exit repeat',
    '  end repeat',
    '  if found then',
    '    return "success"',
    '  else',
    '    return "not_found"',
    '  end if',
    'end tell'
  ];

  const appleScript = appleScriptLines.join('\n');

  try {
    const tempScriptFile = path.join(__dirname, '.temp_otp_script.applescript');
    fs.writeFileSync(tempScriptFile, appleScript, 'utf8');

    const result = execSync(`osascript "${tempScriptFile}"`, { 
      encoding: 'utf8',
      timeout: 10000 
    }).trim();

    // Clean up temp files
    fs.unlinkSync(tempScriptFile);
    fs.unlinkSync(tempJsFile);

    return result;
  } catch (error) {
    console.error('AppleScript execution failed:', error.message);
    return 'error';
  }
}

async function monitorMessagesForOTP() {
  console.log('üîç Monitoring Messages DB for new OTP codes...');
  console.log('üì± Please send or receive an OTP code via Messages');
  
  let lastOTP = await getLatestOTP();
  let attempts = 0;
  const maxAttempts = 60; // 5Î∂ÑÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ (5Ï¥à Í∞ÑÍ≤©)
  
  const monitorInterval = setInterval(async () => {
    attempts++;
    const currentOTP = await getLatestOTP();
    
    if (currentOTP && currentOTP !== lastOTP) {
      console.log(`üîê New OTP detected: ${currentOTP}`);
      clearInterval(monitorInterval);
      
      // OTPÎ•º ÌéòÏù¥ÏßÄÏóê Ï£ºÏûÖ
      const result = await injectOTPToPage(currentOTP);
      
      if (result === 'success') {
        console.log('‚úÖ OTP auto-filled successfully!');
      } else if (result === 'not_found') {
        console.log('‚ùå No nid.naver.com tab found. Please open the page first');
      } else if (result === 'field_not_found') {
        console.log('‚ö†Ô∏è OTP input field not found on the page');
      } else {
        console.log('‚ùå Failed to inject OTP');
      }
      
      return;
    }
    
    if (attempts >= maxAttempts) {
      clearInterval(monitorInterval);
      console.log('‚è∞ Monitoring timeout. No new OTP received in 5 minutes');
      return;
    }
    
    // ÏßÑÌñâ ÏÉÅÌô© ÌëúÏãú
    if (attempts % 12 === 0) { // Îß§ 1Î∂ÑÎßàÎã§
      const remaining = Math.ceil((maxAttempts - attempts) / 12);
      console.log(`‚è≥ Still monitoring... ${remaining} minutes remaining`);
    }
  }, 5000); // 5Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
}

async function main() {
  try {
    // Ï¶âÏãú ÏµúÏã† OTP ÌôïÏù∏
    const immediateOTP = await getLatestOTP();
    if (immediateOTP) {
      console.log(`üîê Found recent OTP: ${immediateOTP}`);
      console.log('üöÄ Attempting to auto-fill...');
      
      const result = await injectOTPToPage(immediateOTP);
      
      if (result === 'success') {
        console.log('‚úÖ OTP auto-filled successfully!');
        return;
      } else if (result === 'not_found') {
        console.log('‚ùå No nid.naver.com tab found');
      } else if (result === 'field_not_found') {
        console.log('‚ö†Ô∏è OTP input field not found');
      }
      
      console.log('');
    }
    
    // ÏÉàÎ°úÏö¥ OTP Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    await monitorMessagesForOTP();
    
  } catch (error) {
    console.log(`‚ùå Error: ${error.message}`);
    process.exit(1);
  }
}

main();
